{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./demo/components/App/Parse.worker.js","webpack:///./node_modules/gitdiff-parser/index.js","webpack:///./node_modules/warning/warning.js","webpack:///./src/parse.js"],"names":["zipChanges","changes","reduce","current","i","result","last","lastDeletionIndex","push","isDelete","isInsert","splice","newLastDeletionIndex","mapHunk","hunk","options","nearbySequences","isPlain","mapFile","file","hunks","map","stubHunk","addStubHunk","parseDiff","text","warning","files","parser","parse","referenceCodeOrLines","length","isStubRequired","linesOfCode","split","lastHunk","lastLineNumber","oldStart","oldLines","newStart","newLines","content"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;AClFkB;;AAElB;AACA;AACA,MAAM,OAAO,kCAAkC;AAC/C,wGAA0C,gBAAgB;;AAE1D,0BAA0B,YAAY;AACtC;AACA;;;;;;;;;;;;ACTA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAMA;AACA,CAAC;;;;;;;;;;;;;AC9ND;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AC/DA;AACA;;AAEA,IAAMA,aAAa,SAAbA,UAAa,UAAW;AAAA,0BACTC,QAAQC,MAAR,CACb,gBAAoCC,OAApC,EAA6CC,CAA7C,EAAmD;AAAA;AAAA,YAAjDC,MAAiD;AAAA,YAAzCC,IAAyC;AAAA,YAAnCC,iBAAmC;;AAC/C,YAAI,CAACD,IAAL,EAAW;AACPD,mBAAOG,IAAP,CAAYL,OAAZ;AACA,mBAAO,CAACE,MAAD,EAASF,OAAT,EAAkBA,QAAQM,QAAR,GAAmBL,CAAnB,GAAuB,CAAC,CAA1C,CAAP;AACH;;AAED,YAAID,QAAQO,QAAR,IAAoBH,qBAAqB,CAA7C,EAAgD;AAC5CF,mBAAOM,MAAP,CAAcJ,oBAAoB,CAAlC,EAAqC,CAArC,EAAwCJ,OAAxC;AACA;AACA,mBAAO,CAACE,MAAD,EAASF,OAAT,EAAkBI,oBAAoB,CAAtC,CAAP;AACH;;AAEDF,eAAOG,IAAP,CAAYL,OAAZ;;AAEA;AACA;AACA,YAAMS,uBAAuBT,QAAQM,QAAR,GAAoBH,KAAKG,QAAL,GAAgBF,iBAAhB,GAAoCH,CAAxD,GAA6DA,CAA1F;;AAEA,eAAO,CAACC,MAAD,EAASF,OAAT,EAAkBS,oBAAlB,CAAP;AACH,KApBY,EAqBb,CAAC,EAAD,EAAK,IAAL,EAAW,CAAC,CAAZ,CArBa,CADS;AAAA;AAAA,QACnBP,MADmB;;AAwB1B,WAAOA,MAAP;AACH,CAzBD;;AA2BA,IAAMQ,UAAU,SAAVA,OAAU,CAACC,IAAD,EAAOC,OAAP,EAAmB;AAC/B,QAAMd,UAAUc,QAAQC,eAAR,KAA4B,KAA5B,GAAoChB,WAAWc,KAAKb,OAAhB,CAApC,GAA+Da,KAAKb,OAApF;;AAEA,wBACOa,IADP;AAEIG,iBAAS,KAFb;AAGIhB,iBAASA;AAHb;AAKH,CARD;;AAUA,IAAMiB,UAAU,SAAVA,OAAU,CAACC,IAAD,EAAOJ,OAAP,EAAmB;AAC/B,QAAMK,QAAQD,KAAKC,KAAL,CAAWC,GAAX,CAAe;AAAA,eAAQR,QAAQC,IAAR,EAAcC,OAAd,CAAR;AAAA,KAAf,CAAd;;AAEA,wBACOI,IADP;AAEIC,eAAOL,QAAQO,QAAR,GAAmBC,YAAYH,KAAZ,CAAnB,GAAwCA;AAFnD;AAIH,CAPD;;AASO,IAAMI,YAAY,SAAZA,SAAY,CAACC,IAAD,EAAwB;AAAA,QAAjBV,OAAiB,uEAAP,EAAO;;AAC7CW,IAAA,8CAAAA,CACI,CAACX,QAAQO,QADb,EAEI,wFACE,6GAHN;;AAMA,QAAMK,QAAQ,qDAAAC,CAAOC,KAAP,CAAaJ,IAAb,CAAd;;AAEA,WAAOE,MAAMN,GAAN,CAAU;AAAA,eAAQH,QAAQC,IAAR,EAAcJ,OAAd,CAAR;AAAA,KAAV,CAAP;AACH,CAVM;;AAYA,IAAMQ,cAAc,SAAdA,WAAc,CAACH,KAAD,EAAQU,oBAAR,EAAiC;AACxD,QAAI,CAACV,KAAD,IAAU,CAACA,MAAMW,MAArB,EAA6B;AACzB,eAAOX,KAAP;AACH;;AAED,QAAMY,iBAAkB,YAAM;AAC1B,YAAI,CAACF,oBAAL,EAA2B;AACvB,mBAAO,IAAP;AACH;;AAED,YAAMG,cAAc,OAAOH,oBAAP,KAAgC,QAAhC,GACdA,qBAAqBI,KAArB,CAA2B,IAA3B,CADc,GAEdJ,oBAFN;AAGA,YAAMK,WAAWf,MAAMA,MAAMW,MAAN,GAAe,CAArB,CAAjB;AACA,YAAMK,iBAAiBD,SAASE,QAAT,GAAoBF,SAASG,QAA7B,GAAwC,CAA/D;;AAEA,eAAOL,YAAYF,MAAZ,GAAqBK,cAA5B;AACH,KAZsB,EAAvB;;AAcA,QAAI,CAACJ,cAAL,EAAqB;AACjB,eAAOZ,KAAP;AACH;;AArBuD,iBAuBPA,MAAMA,MAAMW,MAAN,GAAe,CAArB,CAvBO;AAAA,QAuBjDM,QAvBiD,UAuBjDA,QAvBiD;AAAA,QAuBvCC,QAvBuC,UAuBvCA,QAvBuC;AAAA,QAuB7BC,QAvB6B,UAuB7BA,QAvB6B;AAAA,QAuBnBC,QAvBmB,UAuBnBA,QAvBmB;;AAwBxD,QAAMlB,WAAW;AACbe,kBAAUA,WAAWC,QADR;AAEbA,kBAAU,CAFG;AAGbC,kBAAUA,WAAWC,QAHR;AAIbA,kBAAU,CAJG;AAKbC,iBAAS,MALI;AAMbxC,iBAAS;AANI,KAAjB;AAQA,wCAAWmB,KAAX,IAAkBE,QAAlB;AACH,CAjCM,C","file":"ca15634b4b11eb060dea.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./demo/components/App/Parse.worker.js\");\n","import {parseDiff} from 'react-diff-view/parse';\n\nself.addEventListener(\n    'message',\n    ({data: {jobID, diffText, nearbySequences}}) => {\n        const diff = parseDiff(diffText, {nearbySequences});\n\n        self.postMessage({jobID, diff});\n    }\n);\n","/**\n * @file gitdiff 消息解析器\n * @author errorrik(errorrik@gmail.com)\n */\n\n(function (root) {\n    var STAT_START = 2;\n    var STAT_FILE_META = 3;\n    var STAT_HUNK = 5;\n\n\n\n\n    var parser = {\n        /**\n         * 解析 gitdiff 消息\n         *\n         * @param {string} source gitdiff消息内容\n         * @return {Object}\n         */\n        parse: function (source) {\n            var infos = [];\n            var stat = STAT_START;\n            var currentInfo;\n            var currentHunk;\n            var changeOldLine;\n            var changeNewLine;\n\n\n            var lines = source.split('\\n');\n            var linesLen = lines.length;\n            var i = 0;\n\n            while (i < linesLen) {\n                var line = lines[i];\n\n                if (line.indexOf('diff --git') === 0) {\n                    var filesStr = line.slice(11);\n                    var oldPath = null;\n                    var newPath = null;\n\n                    var quoteIndex = filesStr.indexOf('\"');\n                    switch (quoteIndex) {\n                        case -1:\n                            var segs = filesStr.split(' ');\n                            oldPath = segs[0].slice(2);\n                            newPath = segs[1].slice(2);\n                            break;\n\n                        case 0:\n                            var nextQuoteIndex = filesStr.indexOf('\"', 2);\n                            oldPath = filesStr.slice(3, nextQuoteIndex);\n                            var newQuoteIndex = filesStr.indexOf('\"', nextQuoteIndex + 1);\n                            if (newQuoteIndex < 0) {\n                                newPath = filesStr.slice(nextQuoteIndex + 4);\n                            }\n                            else {\n                                newPath = filesStr.slice(newQuoteIndex + 3, -1);\n                            }\n                            break;\n\n                        default:\n                            var segs = filesStr.split(' ');\n                            oldPath = segs[0].slice(2);\n                            newPath = segs[1].slice(3, -1);\n                            break;\n                    }\n                    \n\n                    // read file\n                    currentInfo = {\n                        oldPath: oldPath,\n                        newPath: newPath,\n                        hunks: []\n                    };\n\n                    infos.push(currentInfo);\n\n\n                    // 1. 如果oldPath是/dev/null就是add\n                    // 2. 如果newPath是/dev/null就是delete\n                    // 3. 如果有 rename from foo.js 这样的就是rename\n                    // 4. 如果有 copy from foo.js 这样的就是copy\n                    // 5. 其它情况是modify\n                    var currentInfoType = null;\n\n                    // read mode change\n                    var nextLine = lines[i + 1];\n                    if (nextLine.indexOf('old') === 0) {\n                        currentInfo.oldMode = nextLine.slice(9, 16);\n                        currentInfo.newMode = lines[i + 2].slice(9, 16);\n                        i += 2;\n                        nextLine = lines[i + 1];\n                    }\n\n                    // read similarity\n                    if (nextLine.indexOf('similarity') === 0) {\n                        currentInfo.similarity = parseInt(nextLine.split(' ')[2], 10);\n                        i += 1;\n                    }\n\n                    // read similarity type and index\n                    var simiLine;\n                    simiLoop: while ((simiLine = lines[++i])) {\n                        var segs = simiLine.split(' ');\n\n                        switch (segs[0]) {\n                            case 'diff': // diff --git\n                                i--;\n                                break simiLoop;\n\n                            case 'index':\n                                var revs = segs[1].split('..');\n                                currentInfo.oldRevision = revs[0];\n                                currentInfo.newRevision = revs[1];\n\n                                if (segs[2]) {\n                                    currentInfo.oldMode = currentInfo.newMode = segs[2];\n                                }\n                                stat = STAT_HUNK;\n\n                                var oldFileName = lines[i + 1];\n                                if (oldFileName.indexOf('---') === 0) {\n                                    var newFileName = lines[i + 2];\n\n                                    if (/\\s\\/dev\\/null$/.test(oldFileName)) {\n                                        currentInfo.oldPath = '/dev/null';\n                                        currentInfoType = 'add';\n                                    }\n                                    else if (/\\s\\/dev\\/null$/.test(newFileName)) {\n                                        currentInfo.newPath = '/dev/null';\n                                        currentInfoType = 'delete';\n                                    }\n\n                                    i += 2;\n                                }\n\n                                break simiLoop;\n\n                        }\n                        \n                        if (!currentInfoType) {\n                            currentInfoType = segs[0];\n                        }\n                    }\n\n                    currentInfo.type = currentInfoType || 'modify';\n                }\n                else if (line.indexOf('Binary') === 0) {\n                    currentInfo.isBinary = true;\n                    stat = STAT_START;\n                    currentInfo = null;\n                }\n                else if (stat === STAT_HUNK) {\n                    if (line.indexOf('@@') === 0) {\n                        var match = /^@@\\s+-([0-9]+)(,([0-9]+))?\\s+\\+([0-9]+)(,([0-9]+))?/.exec(line)\n                        currentHunk = {\n                            content: line,\n                            oldStart: match[1] - 0,\n                            newStart: match[4] - 0,\n                            oldLines: match[3] - 0 || 1,\n                            newLines: match[6] - 0 || 1,\n                            changes: []\n                        };\n\n                        currentInfo.hunks.push(currentHunk);\n                        changeOldLine = currentHunk.oldStart;\n                        changeNewLine = currentHunk.newStart;\n                    }\n                    else {\n                        var typeChar = line.slice(0, 1);\n                        var change = {\n                            content: line.slice(1)\n                        };\n\n                        switch (typeChar) {\n                            case '+':\n                                change.type = 'insert';\n                                change.isInsert = true;\n                                change.lineNumber = changeNewLine;\n                                changeNewLine++;\n                                break;\n\n                            case '-':\n                                change.type = 'delete';\n                                change.isDelete = true;\n                                change.lineNumber = changeOldLine;\n                                changeOldLine++;\n                                break;\n\n                            case ' ':\n                                change.type = 'normal';\n                                change.isNormal = true;\n                                change.oldLineNumber = changeOldLine;\n                                change.newLineNumber = changeNewLine;\n                                changeOldLine++;\n                                changeNewLine++;\n                                break;\n                        }\n\n                        change.type && currentHunk.changes.push(change);\n                    }\n                }\n\n                i++;\n            }\n\n            return infos;\n        }\n    };\n\n    if (typeof exports === 'object' && typeof module === 'object') {\n        // For CommonJS\n        exports = module.exports = parser;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // For AMD\n        define('gitDiffParser', [], parser);\n    }\n    else {\n        root.gitDiffParser = parser;\n    }\n})(this);\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @providesModule warning\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n","import parser from 'gitdiff-parser';\nimport warning from 'warning';\n\nconst zipChanges = changes => {\n    const [result] = changes.reduce(\n        ([result, last, lastDeletionIndex], current, i) => {\n            if (!last) {\n                result.push(current);\n                return [result, current, current.isDelete ? i : -1];\n            }\n\n            if (current.isInsert && lastDeletionIndex >= 0) {\n                result.splice(lastDeletionIndex + 1, 0, current);\n                // The new `lastDeletionIndex` may be out of range, but `splice` will fix it\n                return [result, current, lastDeletionIndex + 2];\n            }\n\n            result.push(current);\n\n            // Keep the `lastDeletionIndex` if there are lines of deletions,\n            // otherwise update it to the new deletion line\n            const newLastDeletionIndex = current.isDelete ? (last.isDelete ? lastDeletionIndex : i) : i;\n\n            return [result, current, newLastDeletionIndex];\n        },\n        [[], null, -1]\n    );\n    return result;\n};\n\nconst mapHunk = (hunk, options) => {\n    const changes = options.nearbySequences === 'zip' ? zipChanges(hunk.changes) : hunk.changes;\n\n    return {\n        ...hunk,\n        isPlain: false,\n        changes: changes\n    };\n};\n\nconst mapFile = (file, options) => {\n    const hunks = file.hunks.map(hunk => mapHunk(hunk, options));\n\n    return {\n        ...file,\n        hunks: options.stubHunk ? addStubHunk(hunks) : hunks\n    };\n};\n\nexport const parseDiff = (text, options = {}) => {\n    warning(\n        !options.stubHunk,\n        'stubHunk options is deprecated, use addStubHunk function later to add a stub hunk, '\n        + 'this function can receive an extra referenceCodeOrLines argument to determine whether stub hunk is required'\n    );\n\n    const files = parser.parse(text);\n\n    return files.map(file => mapFile(file, options));\n};\n\nexport const addStubHunk = (hunks, referenceCodeOrLines) => {\n    if (!hunks || !hunks.length) {\n        return hunks;\n    }\n\n    const isStubRequired = (() => {\n        if (!referenceCodeOrLines) {\n            return true;\n        }\n\n        const linesOfCode = typeof referenceCodeOrLines === 'string'\n            ? referenceCodeOrLines.split('\\n')\n            : referenceCodeOrLines;\n        const lastHunk = hunks[hunks.length - 1];\n        const lastLineNumber = lastHunk.oldStart + lastHunk.oldLines - 1;\n\n        return linesOfCode.length > lastLineNumber;\n    })();\n\n    if (!isStubRequired) {\n        return hunks;\n    }\n\n    const {oldStart, oldLines, newStart, newLines} = hunks[hunks.length - 1];\n    const stubHunk = {\n        oldStart: oldStart + oldLines,\n        oldLines: 0,\n        newStart: newStart + newLines,\n        newLines: 0,\n        content: 'STUB',\n        changes: []\n    };\n    return [...hunks, stubHunk];\n};\n"],"sourceRoot":""}